#!/usr/bin/perl -W

use strict;

use FindBin;
use CGI;
use XML::LibXML;

use lib "$FindBin::Bin";
use WorkflowCommon;

use lib "$FindBin::Bin/LockNLog";
use LockNLog;

my($query)=CGI->new();

# Web applications do need this!
$|=1;
	
my($retval)=0;

# First step, parameter storage (if any!)
foreach my $param ($query->param()) {
	# We are skipping all unknown params
	if($param eq 'eraseWFId') {
		my(@workflowId)=$query->param($param);
		last if($query->cgi_error());
		
		foreach my $wrelpath (@workflowId) {
			# We are only erasing what it is valid...
			next  if(index($wrelpath,'/')==0 || index($wrelpath,'../')!=-1 || ! ($wrelpath =~ /\.xml$/));
			
			my($wrelpathxml)=$WorkflowCommon::WORKFLOWDIR.'/'.$wrelpath;
			my($wrelpathsvg)=$wrelpathxml;
			$wrelpathsvg =~ s/\.xml$/.svg/;
			
			# Checking rules should be inserted here...
			
			# And last, unlink!
			unlink($wrelpathxml);
			unlink($wrelpathsvg);
		}
	} elsif($param eq 'workflow') {
		# Now, time to recognize the content
		my @UPHL=$query->upload($param);
		
		last if($query->cgi_error());
		
		my($isfh)=1;
		
		if(scalar(@UPHL)==0) {
			@UPHL=$query->param($param);
			$isfh=undef;
		}
		
		foreach my $UPH (@UPHL) {
			# Generating a unique identifier
			my($randname);
			my($randfilexml);
			my($randfilesvg);
#			my($randfilepng);
#			my($randfilepdf);
			do {
				$randname=WorkflowCommon::genUUID();
				$randfilexml=$WorkflowCommon::WORKFLOWDIR.'/'.$randname.'.xml';
				$randfilesvg=$WorkflowCommon::WORKFLOWDIR.'/'.$randname.'.svg';
#				$randfilepng=$WorkflowCommon::WORKFLOWDIR.'/'.$randname.'.png';
#				$randfilepdf=$WorkflowCommon::WORKFLOWDIR.'/'.$randname.'.pdf';
			} while(-f $randfilexml);
			
			# Saving the workflow data
			my($WFH);
			if(open($WFH,'>',$randfilexml)) {
				if(defined($isfh)) {
					# It is a file
					my($line);
					while($line=<$UPH>) {
						print $WFH $line;
					}
				} else {
					# It is a text field
					print $WFH $UPH;
				}
				close($WFH);
				
				# Now it is time to validate it!
				$retval=system($WorkflowCommon::LAUNCHERDIR.'/bin/inbworkflowparser',
					'-baseDir',$WorkflowCommon::MAVENDIR,
					'-workflow',$randfilexml,
					'-svggraph',$randfilesvg,
#					'-pnggraph',$randfilepng,
#					'-pdfgraph',$randfilepdf,
					'-expandSubWorkflows');
				
				# If it failed, it is better erasing the workflow
				# because it is not a valid one!
				if($retval!=0) {
					unlink($randfilexml);
					last;
				}
			}
		}
	}
}

# We must signal here errors and exit
if($retval!=0 || $query->cgi_error()) {
	my $error = $query->cgi_error;
	$error = '500 Internal Server Error'  unless(defined($error));
	print $query->header(-status=>$error),
		$query->start_html('Problems'),
		$query->h2('Request not processed because '.(($retval!=0)?'uploaded workflow was malformed':'upload was interrupted')),
		$query->strong($error);
	exit 0;
}

# Second step, workflow repository report

my(@dirstack)=('.');
my(@workflowlist)=();

# Looking for workflows
foreach my $dir (@dirstack) {
	my($WFDIR);
	my($fdir)=$WorkflowCommon::WORKFLOWDIR.'/'.$dir;
	if(opendir($WFDIR,$fdir)) {
		my($entry);
		while($entry=readdir($WFDIR)) {
			next if(index($entry,'.')==0);
			
			my($fentry)=$fdir.'/'.$entry;
			my($rentry)=($dir ne '.')?($dir.'/'.$entry):$entry;
			if($entry =~ /\.xml$/ && -f $fentry && -r $fentry) {
				push(@workflowlist,$rentry);
			} elsif(-d $fentry) {
				push(@dirstack,$rentry);
			}
		}
		closedir($WFDIR);
	}
}

my $outputDoc = XML::LibXML::Document->createDocument();
my($root)=$outputDoc->createElementNS($WorkflowCommon::WFD_NS,'workflowlist');
$root->setAttribute('time',LockNLog::getPrintableNow());
$outputDoc->setDocumentElement($root);
$root->appendChild($outputDoc->createComment( <<COMMENTEOF ));
	This content was generated by workflowmanager, an
	application of the network workflow enactor from INB.
	The workflow enactor itself is based on Taverna core,
	and uses it.
	
	Author: José María Fernández González (C) 2007
	Institutions:
	*	Spanish National Cancer Research Institute (CNIO, http://www.cnio.es/)
	*	Spanish National Bioinformatics Institute (INB, http://www.inab.org/)
COMMENTEOF

my $parser = XML::LibXML->new();

foreach my $wf (@workflowlist) {
	eval {
		my $doc = $parser->parse_file($WorkflowCommon::WORKFLOWDIR.'/'.$wf);
		# Getting description from workflow definition
		my @nodelist = $doc->getElementsByTagNameNS($WorkflowCommon::SCUFL_NS,'workflowdescription');
		if(scalar(@nodelist)>0) {
			my $wfe = $outputDoc->createElementNS($WorkflowCommon::WFD_NS,'workflow');
			my($desc)=$nodelist[0];
			$wfe->setAttribute('lsid',$desc->getAttribute('lsid'));
			$wfe->setAttribute('author',$desc->getAttribute('author'));
			$wfe->setAttribute('title',$desc->getAttribute('title'));
			$wfe->setAttribute('path',$wf);
			my $svg = $wf;
			$svg =~ s/\.xml$/\.svg/;
			$wfe->setAttribute('svg',$svg);
			
			# Getting the workflow description
			my($wdesc)=$outputDoc->createElementNS($WorkflowCommon::WFD_NS,'description');
			$wdesc->appendChild($outputDoc->createCDATASection($desc->textContent()));
			$wfe->appendChild($wdesc);
			
			# Getting Inputs
			@nodelist = $doc->getElementsByTagNameNS($WorkflowCommon::SCUFL_NS,'source');
			foreach my $source (@nodelist) {
				my $input = $outputDoc->createElementNS($WorkflowCommon::WFD_NS,'input');
				$input->setAttribute('name',$source->getAttribute('name'));
				
				# Description
				my(@sourcedesc)=$source->getElementsByTagNameNS($WorkflowCommon::SCUFL_NS,'description');
				if(scalar(@sourcedesc)>0) {
					my($descnode)=$outputDoc->createElementNS($WorkflowCommon::WFD_NS,'description');
					$descnode->appendChild($outputDoc->createCDATASection($sourcedesc[0]->textContent()));
					$input->appendChild($descnode);
				}
				
				# MIME types handling
				my(@mimetypes)=$source->getElementsByTagNameNS($WorkflowCommon::SCUFL_NS,'mimetype');
				# Taverna default mime type
				push(@mimetypes,'text/plain')  if(scalar(@mimetypes)==0);
				foreach my $mime (@mimetypes) {
					my $mtype = $outputDoc->createElementNS($WorkflowCommon::WFD_NS,'mime');
					$mtype->setAttribute('type',$mime);
					$input->appendChild($mtype);
				}
				
				# At last, appending this input
				$wfe->appendChild($input);
			}
			
			# And Outputs
			@nodelist = $doc->getElementsByTagNameNS($WorkflowCommon::SCUFL_NS,'sink');
			foreach my $sink (@nodelist) {
				my $output = $outputDoc->createElementNS($WorkflowCommon::WFD_NS,'output');
				$output->setAttribute('name',$sink->getAttribute('name'));
				
				# Description
				my(@sinkdesc)=$sink->getElementsByTagNameNS($WorkflowCommon::SCUFL_NS,'description');
				if(scalar(@sinkdesc)>0) {
					my($descnode)=$outputDoc->createElementNS($WorkflowCommon::WFD_NS,'description');
					$descnode->appendChild($outputDoc->createCDATASection($sinkdesc[0]->textContent()));
					$output->appendChild($descnode);
				}
				
				# MIME types handling
				my(@mimetypes)=$sink->getElementsByTagNameNS($WorkflowCommon::SCUFL_NS,'mimetype');
				# Taverna default mime type
				push(@mimetypes,'text/plain')  if(scalar(@mimetypes)==0);
				foreach my $mime (@mimetypes) {
					my $mtype = $outputDoc->createElementNS($WorkflowCommon::WFD_NS,'mime');
					$mtype->setAttribute('type',$mime);
					$output->appendChild($mtype);
				}
				
				# At last, appending this output
				$wfe->appendChild($output);
			}
			
			# At last, appending the new workflow entry
			$root->appendChild($wfe);
		}
	};
	
	if($@) {
		$root->appendChild($outputDoc->createComment("Unable to process $wf due ".$@));
	}
}

print $query->header('text/xml');

$outputDoc->toFH(\*STDOUT);

exit 0;
