#!/usr/bin/perl -W

use strict;

use FindBin;
use CGI;
use XML::LibXML;

use lib "$FindBin::Bin";
use WorkflowCommon;

use lib "$FindBin::Bin/LockNLog";
use LockNLog;

sub appendInputs($$$);
sub appendOutputs($$$);
sub appendIO($$$$);
sub appendResults($$$);

sub appendInputs($$$) {
	appendIO($_[0],$_[1],$_[2],'input');
}

sub appendOutputs($$$) {
	appendIO($_[0],$_[1],$_[2],'output');
}

sub appendIO($$$$) {
	my($iodir,$outputDoc,$parent,$iotagname)=@_;
	
	if(-d $iodir) {
		my($IODIR);
		if(opendir($IODIR,$iodir)) {
			my($entry);
			while($entry=readdir($IODIR)) {
				# No hidden element, please!
				next  if($entry eq '.' || $entry eq '..');

				my($ionode)=$outputDoc->createElementNS($WorkflowCommon::WFD_NS,$iotagname);
				$ionode->setAttribute('name',$entry);
				$parent->appendChild($ionode);
			}
			closedir($IODIR);
		}
	}
}

sub processStep($$$) {
	my($basedir,$outputDoc,$es)=@_;
	
	my($inputsdir)=$basedir . '/Inputs';
	my($outputsdir)=$basedir . '/Outputs';
	my($resultsdir)=$basedir . '/Results';
	appendInputs($inputsdir,$outputDoc,$es);
	appendOutputs($outputsdir,$outputDoc,$es);
	appendResults($resultsdir,$outputDoc,$es);
}

sub appendResults($$$) {
	my($resultsdir,$outputDoc,$parent)=@_;
	
	if(-d $resultsdir) {
		my($RDIR);
		if(opendir($RDIR,$resultsdir)) {
			my($entry);
			while($entry=readdir($RDIR)) {
				# No hidden element, please!
				my($jobdir)=$resultsdir .'/'. $entry;
				next  if($entry eq '.' || $entry eq '..' || ! -d $jobdir);
				
				my($step)=$outputDoc->createElementNS($WorkflowCommon::WFD_NS,'step');
				$step->setAttribute('name',$entry);
				
				# Now we have a pid, we can check for the enaction job
				my($state)=undef;
				my($includeSubs)=1;
				if( -f $jobdir . '/FINISHED') {
					$state = 'finished';
				} elsif( -f $jobdir . '/FAILED.txt') {
					$state = 'error';
				} elsif( -f $jobdir . '/START') {
						$state = 'running';
				} else {
					# So it could be queued
					$state = 'queued';
					$includeSubs=undef;
				}
				
				$step->setAttribute('state',$state);
				
				if(defined($includeSubs)) {
					appendInputs($jobdir . '/Inputs',$outputDoc,$step);
					appendOutputs($jobdir . '/Outputs',$outputDoc,$step);
					
					my($iteratedir)=$jobdir . '/Iterations';
					if(-d $iteratedir) {
						my($iternode)=$outputDoc->createElementNS($WorkflowCommon::WFD_NS,'iterations');
						$parent->appendChild($iternode);
						appendResults($iteratedir,$outputDoc,$iternode);
					}
				}
				
				$parent->appendChild($step);
			}
			closedir($RDIR);
		}
	}
}


my($query)=CGI->new();

# Web applications do need this!
$|=1;
	
my($retval)=0;

my($outputDoc)=undef;
my($root)=undef;

# First step, parameter storage (if any!)
foreach my $param ($query->param()) {
	next unless($param eq 'jobId');
	
	my(@jobIdList)=$query->param($param);
	last  if($query->cgi_error());
	
	unless(defined($outputDoc)) {
		$outputDoc=XML::LibXML::Document->createDocument();
		$root=$outputDoc->createElementNS($WorkflowCommon::WFD_NS,'enactionreport');
		$outputDoc->setDocumentElement($root);
		$root->appendChild($outputDoc->createComment( <<COMMENTEOF ));
	This content was generated by enactionstatus, an
	application of the network workflow enactor from INB.
	The workflow enactor itself is based on Taverna core,
	and uses it.

	Author: José María Fernández González (C) 2007
	Institutions:
	*	Spanish National Cancer Research Institute (CNIO, http://www.cnio.es/)
	*	Spanish National Bioinformatics Institute (INB, http://www.inab.org/)
COMMENTEOF
	}
	
	foreach my $jobId (@jobIdList) {
		my($es)=$outputDoc->createElementNS($WorkflowCommon::WFD_NS,'enactionstatus');
		$es->setAttribute('jobId',$jobId);
		$es->setAttribute('time',LockNLog::getPrintableNow());
		
		# Time to know the overall status of this enaction
		my($state)=undef;
		my($jobdir)=$WorkflowCommon::JOBDIR . '/' .$jobId;
		
		# Is it a valid job id?
		if(index($jobId,'/')==-1 && -d $jobdir && -r $jobdir) {
			#
			my($pidfile)=$jobdir . '/PID';
			my($includeSubs)=1;
			my($PID);
			if(-f $jobdir . '/FATAL' || ! -f $pidfile) {
				$state='dead';
			} elsif(open($PID,'<',$pidfile)) {
				my($pid)=<$PID>;
				close($PID);
				
				# Now we have a pid, we can check for the enaction job
				if( -f $jobdir . '/FINISHED') {
					$state = 'finished';
				} elsif( -f $jobdir . '/FAILED.txt') {
					$state = 'error';
				} elsif(kill(0,$pid) > 0) {
					# It could be still running...
					if( -f $jobdir . '/START') {
						$state = 'running';
					} else {
						# So it could be queued
						$state = 'queued';
						$includeSubs=undef;
					}
				} else {
					$state = 'dead';
				}
			} else {
				$state = 'fatal';
				$includeSubs=undef;
			}
			
			# Now including subinformation...
			if(defined($includeSubs)) {
				processStep($jobdir,$outputDoc,$es);
			}
		}
		
		$state='unknown'  unless(defined($state));
		
		$es->setAttribute('state',$state);
		$root->appendChild($es);
	}
}

$retval=1  unless(defined($outputDoc));

# We must signal here errors and exit
if($retval!=0 || $query->cgi_error()) {
	my $error = $query->cgi_error;
	$error = '500 Internal Server Error'  unless(defined($error));
	print $query->header(-status=>$error),
		$query->start_html('Problems'),
		$query->h2('Request not processed because no jobId was properly provided'),
		$query->strong($error);
	exit 0;
}

print $query->header('text/xml');

$outputDoc->toFH(\*STDOUT);

exit 0;
